# Copyright (c) 2023 - 2025 Chair for Design Automation, TUM
# Copyright (c) 2025 Munich Quantum Software Company GmbH
# All rights reserved.
#
# SPDX-License-Identifier: MIT
#
# Licensed under the MIT License

"""Python bindings for hybrid mapper module."""

import typing
from enum import Enum

from mqt.core.ir import QuantumComputation

class InitialCoordinateMapping(Enum):
    random = ...
    trivial = ...

class InitialCircuitMapping(Enum):
    identity = ...
    graph = ...

class MapperParameters:
    decay: float
    dynamic_mapping_weight: float
    gate_weight: float
    initial_coord_mapping: InitialCoordinateMapping
    limit_shuttling_layer: int
    lookahead_depth: int
    lookahead_weight_moves: float
    lookahead_weight_swaps: float
    max_bridge_distance: int
    num_flying_ancillas: int
    seed: int
    shuttling_time_weight: float
    shuttling_weight: float
    use_pass_by: bool
    verbose: bool
    def __init__(self) -> None: ...

class MapperStats:
    num_bridges: int
    num_f_ancillas: int
    num_moves: int
    num_pass_by: int
    num_swaps: int
    def __init__(self) -> None: ...

class NeutralAtomHybridArchitecture:
    name: str
    def __init__(self, filename: str) -> None: ...
    def compute_swap_distance(self, idx1: typing.SupportsInt, idx2: typing.SupportsInt) -> int: ...
    def get_gate_average_fidelity(self, s: str) -> float: ...
    def get_gate_time(self, s: str) -> float: ...
    def get_nearby_coordinates(self, idx: typing.SupportsInt) -> set[int]: ...
    def load_json(self, json_filename: str) -> None: ...
    @property
    def blocking_factor(self) -> float: ...
    @property
    def decoherence_time(self) -> float: ...
    @property
    def inter_qubit_distance(self) -> float: ...
    @property
    def interaction_radius(self) -> float: ...
    @property
    def naod_coordinates(self) -> int: ...
    @property
    def naod_intermediate_levels(self) -> int: ...
    @property
    def num_aods(self) -> int: ...
    @property
    def num_columns(self) -> int: ...
    @property
    def num_positions(self) -> int: ...
    @property
    def num_qubits(self) -> int: ...
    @property
    def num_rows(self) -> int: ...

class HybridNAMapper:
    def __init__(self, arch: NeutralAtomHybridArchitecture, params: MapperParameters) -> None: ...
    def get_animation_viz(self) -> str: ...
    def get_init_hw_pos(self) -> dict[int, int]: ...
    def get_mapped_qc_qasm(self) -> str: ...
    def get_mapped_qc_aod_qasm(self) -> str: ...
    def get_stats(self) -> dict[str, float]: ...
    def map(self, circ: QuantumComputation, initial_mapping: InitialCircuitMapping = ...) -> None: ...
    def map_qasm_file(self, filename: str, initial_mapping: InitialCircuitMapping = ...) -> None: ...
    def save_animation_files(self, filename: str) -> None: ...
    def save_mapped_qc_aod_qasm(self, filename: str) -> None: ...
    def schedule(
        self,
        verbose: bool = ...,
        create_animation_csv: bool = ...,
        shuttling_speed_factor: typing.SupportsFloat = ...,
    ) -> dict[str, float]: ...
    def set_parameters(self, params: MapperParameters) -> None: ...

# noinspection DuplicatedCode
class HybridSynthesisMapper:
    def __init__(self, arch: NeutralAtomHybridArchitecture, params: MapperParameters = ...) -> None: ...
    def append_with_mapping(self, qc: QuantumComputation) -> None: ...
    def append_without_mapping(self, qc: QuantumComputation) -> None: ...
    def complete_remap(self, initial_mapping: InitialCircuitMapping = ...) -> None: ...
    def convert_to_aod(self) -> None: ...
    def evaluate_synthesis_steps(
        self, synthesis_steps: list[QuantumComputation], also_map: bool = ...
    ) -> list[float]: ...
    def get_circuit_adjacency_matrix(self) -> list[list[int]]: ...
    def get_mapped_qc_qasm(self) -> str: ...
    def get_mapped_qc_aod_qasm(self) -> str: ...
    def get_synthesized_qc_qasm(self) -> str: ...
    def init_mapping(self, n_qubits: typing.SupportsInt) -> None: ...
    def save_mapped_qc_qasm(self, filename: str) -> None: ...
    def save_mapped_qc_aod_qasm(self, filename: str) -> None: ...
    def save_synthesized_qc_qasm(self, filename: str) -> None: ...
    def schedule(
        self, verbose: bool = ..., create_animation_csv: bool = ..., shuttling_speed_factor: typing.SupportsFloat = ...
    ) -> dict[str, float]: ...
    def set_parameters(self, params: MapperParameters) -> None: ...
